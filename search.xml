<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>专业</title>
      <link href="/2022/08/18/major/"/>
      <url>/2022/08/18/major/</url>
      
        <content type="html"><![CDATA[<p>能力配不上野心，是所有烦扰的根源。这个世界是公平的，你要想得到，就得学会付出和坚持。每个人都是通过自己的努力，去决定生活的样子。</p><h2 id="第四篇"><a href="#第四篇" class="headerlink" title="第四篇"></a>第四篇</h2><h3 id="Promise是什么"><a href="#Promise是什么" class="headerlink" title="Promise是什么"></a>Promise是什么</h3><p><code>Promise 是异步编程的一种解决方案,简单说就是一个容器，里面保存着某个未来才会结束的事件的结果。 从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。</code><br><code>Promise的实例有三个状态: Pending（进行中） Resolved（已完成） Rejected（已拒绝）</code><br>当把一件事情交给promise时，它的状态就是Pending，任务完成了状态就变成了Resolved、没有完成失败了就变成了Rejected。<br>Promise.then()（微任务）</p><p>Promise的实例有两个过程<br>pending -&gt; fulfilled : Resolved（已完成）<br>pending -&gt; rejected：Rejected（已拒绝）<br>需要注意：一旦从进行状态变成为其他状态就永远不能更改状态了</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>1、将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。流程更加清晰，代码更加优雅。<br>2、Promise对象提供统一的接口，使得控制异步操作更加容易。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>1、无法取消Promise，一旦新建它就会立即执行，无法中途取消。<br>2、如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。<br>3、当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p><h3 id="同步任务和异步任务"><a href="#同步任务和异步任务" class="headerlink" title="同步任务和异步任务"></a>同步任务和异步任务</h3><blockquote><p>1、同步任务： 在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务。是由 js 执行栈/回调栈执行的</p><p>2、异步任务： 不进入主线程、而进入任务队列的任务，当主线程中的任务运行完成了，才会从任务队列中取出异步任务，放入主线程中执行</p><p>微任务和宏任务都是异步任务，它们都属于一个队列</p><p>宏任务是由宿主环境发起的，比如浏览器、Node等，宏任务的异步代码有：<br>script（代码块）<br>setTimeout / setInterval 定时器<br>setImmediate 定时器<br>……等等</p><p>微任务是由JS引擎发起的，微任务的异步代码有：<br>process.nextTick (node)<br>Promise.then( )/catch( ) 。注意，Promise本身同步，只是它里面的then/catch的回调函数是异步的微任务<br>Async/Await<br>Object.observe<br>……等等</p></blockquote><h3 id="任务的执行顺序"><a href="#任务的执行顺序" class="headerlink" title="任务的执行顺序"></a>任务的执行顺序</h3><blockquote><p>执行顺序就为： 同步任务 —&gt; 微任务 —&gt; 宏任务</p></blockquote><h3 id="宏任务与微任务区别"><a href="#宏任务与微任务区别" class="headerlink" title="宏任务与微任务区别"></a>宏任务与微任务区别</h3><blockquote><p>执行顺序：每次事件循环迭代结束时，只执行一次宏任务。而在执行完宏任务后，如果有微任务存在，则会立即执行所有的微任务。因此，微任务会比宏任务更快地执行。<br>执行时机：宏任务的执行时机较为固定，例如定时器、异步函数等。而微任务的执行时机则取决于其所在的任务队列是否被清空。如果一个微任务队列中还有任务，那么这些任务会在下一个宏任务执行前被全部执行。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 专业技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> HTML </tag>
            
            <tag> css </tag>
            
            <tag> VUE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>问题</title>
      <link href="/2022/08/18/problem/"/>
      <url>/2022/08/18/problem/</url>
      
        <content type="html"><![CDATA[<p>不开心的时候，尽量少说话多睡觉，鸡汤再有理，终究是别人的总结，故事再励志，也只是别人的经历，只有你自己才能改变自己，不求很成功，但求不后悔，你要明白，争气永远比生气聪明！</p><h2 id="第五篇"><a href="#第五篇" class="headerlink" title="第五篇"></a>第五篇</h2><h3 id="待添加。。。"><a href="#待添加。。。" class="headerlink" title="待添加。。。"></a>待添加。。。</h3><pre class=" language-bash"><code class="language-bash">待添加。。。</code></pre><p>百度: <a href="https://www.baidu.com/">一下</a></p><h3 id="待添加。。。-1"><a href="#待添加。。。-1" class="headerlink" title="待添加。。。"></a>待添加。。。</h3><pre class=" language-bash"><code class="language-bash">待添加。。。</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="待添加。。。-2"><a href="#待添加。。。-2" class="headerlink" title="待添加。。。"></a>待添加。。。</h3><pre class=" language-bash"><code class="language-bash">待添加。。。</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="待添加。。。-3"><a href="#待添加。。。-3" class="headerlink" title="待添加。。。"></a>待添加。。。</h3><pre class=" language-bash"><code class="language-bash">待添加。。。</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> HTML </tag>
            
            <tag> css </tag>
            
            <tag> VUE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>规划</title>
      <link href="/2022/08/18/plan/"/>
      <url>/2022/08/18/plan/</url>
      
        <content type="html"><![CDATA[<p>当我们开始铺设职业之路时，同样也需要科学地选择和设定自己的目标顺序，一方面注意寻找新的目标，另一方面不断积累阅历，逐步实现人生发展计划。</p><h2 id="第六篇"><a href="#第六篇" class="headerlink" title="第六篇"></a>第六篇</h2><h3 id="待添加。。。"><a href="#待添加。。。" class="headerlink" title="待添加。。。"></a>待添加。。。</h3><pre class=" language-bash"><code class="language-bash">待添加。。。</code></pre><p>百度: <a href="https://www.baidu.com/">一下</a></p><h3 id="待添加。。。-1"><a href="#待添加。。。-1" class="headerlink" title="待添加。。。"></a>待添加。。。</h3><pre class=" language-bash"><code class="language-bash">待添加。。。</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="待添加。。。-2"><a href="#待添加。。。-2" class="headerlink" title="待添加。。。"></a>待添加。。。</h3><pre class=" language-bash"><code class="language-bash">待添加。。。</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="待添加。。。-3"><a href="#待添加。。。-3" class="headerlink" title="待添加。。。"></a>待添加。。。</h3><pre class=" language-bash"><code class="language-bash">待添加。。。</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 未来规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 未来 </tag>
            
            <tag> 现在 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>知识点</title>
      <link href="/2022/08/18/knowledge/"/>
      <url>/2022/08/18/knowledge/</url>
      
        <content type="html"><![CDATA[<p>虽然在学习的过程中会遇到许多不顺心的事，但古人说得好——吃一堑，长一智。多了一次失败，就多了一次教训；多了一次挫折，就多了一次经验。没有失败和挫折的人，是永远不会成功的。</p><h2 id="第三篇"><a href="#第三篇" class="headerlink" title="第三篇"></a>第三篇</h2><h3 id="如何理解-HTML-语义化"><a href="#如何理解-HTML-语义化" class="headerlink" title="如何理解 HTML 语义化"></a>如何理解 HTML 语义化</h3><p><code>HTML 让人更容易读懂（增加代码可读性）。 让搜索引擎更容易读懂，有助于爬虫抓取更多的有效信息，爬虫依赖于标签来确定上下文和各个关键字的权重（SEO）。 在没有 CSS 样式下，页面也能呈现出很好地内容结构、代码结构。</code></p><h3 id="Axios-是一个用于发起异步请求的技术："><a href="#Axios-是一个用于发起异步请求的技术：" class="headerlink" title="Axios 是一个用于发起异步请求的技术："></a>Axios 是一个用于发起异步请求的技术：</h3><h5 id="CDN-引入："><a href="#CDN-引入：" class="headerlink" title="CDN 引入："></a>CDN 引入：</h5><pre class=" language-JavaScript"><code class="language-JavaScript">src="https://unpkg.com/axios/dist/axios.min.js"</code></pre><h5 id="发送-GET-请求："><a href="#发送-GET-请求：" class="headerlink" title="发送 GET 请求："></a>发送 GET 请求：</h5><pre class=" language-JavaScript"><code class="language-JavaScript">axios.get("http://localhost:8081/user",{ params: { id: id }, headers: { token: token }}).then(res => {    console.log(res);}).catch(err => {    console.error(err);})</code></pre><h5 id="发送-POST-请求："><a href="#发送-POST-请求：" class="headerlink" title="发送 POST  请求："></a>发送 POST  请求：</h5><pre class=" language-JavaScript"><code class="language-JavaScript">axios.post("http://localhost:8081/save",{id:id,name:'name'}, { headers: { 'token': token }}).then(res => {    console.log(res);}).catch(err => {    console.error(err); })</code></pre><!-- More info: [Server](https://hexo.io/docs/server.html) --><h2 id="async-x2F-await"><a href="#async-x2F-await" class="headerlink" title="async/await"></a>async/await</h2><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>async/await是非常棒的语法糖，可以说他是解决异步问题的最终解决方案。从字面意思来理解。async 是异步的意思，而 await 是 等待 ，所以理解 async用于申明一个function是异步的，而 await 用于等待一个异步方法执行完成。</p><h2 id="async作用"><a href="#async作用" class="headerlink" title="async作用"></a>async作用</h2><p>async声明function是一个异步函数，返回一个promise对象，可以使用 then 方法添加回调函数。async函数内部return语句返回的值，会成为then方法回调函数的参数。</p><h2 id="await"><a href="#await" class="headerlink" title="await"></a>await</h2><p>await 操作符只能在异步函数 async function 内部使用。如果一个 Promise 被传递给一个 await 操作符，await 将等待 Promise 正常处理完成并返回其处理结果，也就是说它会阻塞后面的代码，等待 Promise 对象结果。如果等待的不是 Promise 对象，则返回该值本身。</p><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>如果await后面的异步操作出错，那么等同于async函数返回的 Promise 对象被reject。</p><pre class=" language-JavaScript"><code class="language-JavaScript">async function test() {  await Promise.reject('错误了')};test().then(res=>{  console.log('success',res);},err=>{  console.log('err ',err);})// err 错误了</code></pre><p>防止出错的方法，也是将其放在try…catch代码块之中。</p><pre class=" language-JavaScript"><code class="language-JavaScript">async function test() {  try {    await new Promise(function (resolve, reject) {      throw new Error('错误了');    });  } catch(e) {      console.log('err', e)  }  return await('成功了');}</code></pre><p>多个await命令后面的异步操作，如果不存在继发关系（即互不依赖），最好让它们同时触发。</p><pre class=" language-JavaScript"><code class="language-JavaScript">let foo = await getFoo();let bar = await getBar();// 上面这样写法 getFoo完成以后，才会执行getBar// 同时触发写法 ↓// 写法一let [foo, bar] = await Promise.all([getFoo(), getBar()]);// 写法二let fooPromise = getFoo();let barPromise = getBar();let foo = await fooPromise;let bar = await barPromise;</code></pre><h2 id="async-x2F-await优点"><a href="#async-x2F-await优点" class="headerlink" title="async/await优点"></a>async/await优点</h2><p>async/await的优势在于处理由多个Promise组成的 then 链，在之前的Promise文章中提过用then处理回调地狱的问题，async/await相当于对promise的进一步优化。<br>假设一个业务，分多个步骤，且每个步骤都是异步的，而且依赖上个步骤的执行结果。</p>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> HTML </tag>
            
            <tag> css </tag>
            
            <tag> VUE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笔记</title>
      <link href="/2022/08/18/note/"/>
      <url>/2022/08/18/note/</url>
      
        <content type="html"><![CDATA[<p>人们常觉得准备的阶段是在浪费时间，只有当真正机会来临，而自己没有能力把握的时候，才能觉悟自己平时没有准备才是浪费了时间。——法国：罗曼·罗兰</p><h2 id="第七篇"><a href="#第七篇" class="headerlink" title="第七篇"></a>第七篇</h2><h3 id="nextTick作用"><a href="#nextTick作用" class="headerlink" title="nextTick作用"></a>nextTick作用</h3><pre class=" language-bash"><code class="language-bash">Vue 在更新 DOM 时是异步的，所以如果你希望在 DOM 更新后执行某些操作，应该放在 <span class="token variable">$nextTick</span> 中。</code></pre><p>百度: <a href="https://www.baidu.com/">一下</a></p><h3 id="activated函数的作用"><a href="#activated函数的作用" class="headerlink" title="activated函数的作用"></a>activated函数的作用</h3><pre class=" language-bash"><code class="language-bash">activated<span class="token punctuation">(</span><span class="token punctuation">)</span>函数就是一个页面激活后的钩子函数，一进入页面就触发；当我们运用了组件缓存时，如果想每次切换都发送一次请求的话，需要把请求函数写在activated中，而写在created或mounted中其只会在首次加载该组件的时候起作用。</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="vue2-和-vue3-的区别"><a href="#vue2-和-vue3-的区别" class="headerlink" title="vue2 和 vue3 的区别"></a>vue2 和 vue3 的区别</h3><blockquote><p>1、vue2 vue3 响应式原理不同<br>（1）vue2 的双向数据绑定是利用 ES5 的一个 APIObject.definePropert()对数据进行劫持 结合 发布订阅模式的方式来实现的<br>（2）vue3 利用 Proxy 实现数据挟持，创建一个对象的代理，实现基本操作的拦截和自定义。本质上是通过拦截对象的内部方法的执行实现代理。Vue3 中提供了 reactive()和 ref()两个方法将目标数据变为响应式数据。</p></blockquote><blockquote><p>2、vue3 支持碎片，vue 不支持<br>vue3 中组件的 template 下可以包含多个根节点， vue2 中组件的 template 下只能包含一个根节点</p></blockquote><blockquote><p>3、vue2 是选项式 API，vue3 是组合式 API<br>vue2 选项式 api 在代码里分割了不同得属性：data,methods,computed 等，同一块业务逻辑会把数据和方法拆分到不同的代码块中，开发式需要不断上下滚动代码，开发很不方便。<br>vue3 组合式 api 能让相同的业务的数据方法写在同一块代码区域，这样代码会更加简便和整洁</p></blockquote><blockquote><p>4、生命周期不同<br>vue3没有created和beforeCreate<br>vue3生命周期钩子函数都是以on开头</p></blockquote><blockquote><p>5、v-if 和 v-for 的优先级不同<br>vue2 v-for 优先于 v-if 生效,每次都要先渲染才会进行条件判断,会带来性能的浪费。最好不要把 v-if 和 v-for 同时用在一个元素上<br>vue3 v-if 优先于 v-for 生效,把 v-if 和 v-for 同时用在一个元素上 vue 中会给我们报警告</p></blockquote><blockquote><p>6、diff 算法不同</p></blockquote><blockquote><p>7、vue3 新增 Teleport 传送门组件</p></blockquote><p>详情地址：(<a href="https://juejin.cn/post/7204735262961614905?from=search-suggest">https://juejin.cn/post/7204735262961614905?from=search-suggest</a>)</p><h3 id="VUE2给el-dialog添加loading"><a href="#VUE2给el-dialog添加loading" class="headerlink" title="VUE2给el-dialog添加loading"></a>VUE2给el-dialog添加loading</h3><blockquote><p>async change() {<br>  let loading = this.$loading({<br>    target: ‘.el-dialog’<br>  })<br>  try {<br>    // 业务代码<br>    }<br>  } finally {<br>    loading.close()<br>}</p></blockquote><h3 id="forEach和map的区别"><a href="#forEach和map的区别" class="headerlink" title="forEach和map的区别"></a>forEach和map的区别</h3><blockquote><p>forEach()会改变原来的数组，不会返回有意义的值。<br>map()不会改变原来的数组，而是返回一个新的值。<br>它们都是通过遍历数组，对数组的每个元素执行特定的函数。<br>区别主要在于它们处理函数返回值的方式不同。forEach 忽略函数的返回值，而 map 则将函数的返回值收集到一个新的数组中。</p></blockquote><h3 id="＜iframe＞重载方法"><a href="#＜iframe＞重载方法" class="headerlink" title="＜iframe＞重载方法"></a>＜iframe＞重载方法</h3><blockquote><p>方法1</p><pre class=" language-bash"><code class="language-bash">document.getElementById<span class="token punctuation">(</span><span class="token string">'iframeId'</span><span class="token punctuation">)</span>.contentWindow.location.reload<span class="token punctuation">(</span>true<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>方法2</p><pre class=" language-bash"><code class="language-bash">document.getElementById<span class="token punctuation">(</span><span class="token string">'iframeId'</span><span class="token punctuation">)</span>.src<span class="token operator">=</span>url<span class="token punctuation">;</span></code></pre><p>方法3</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">$(</span><span class="token string">"#iframeId"</span><span class="token punctuation">)</span>.attr<span class="token punctuation">(</span><span class="token string">'src'</span>, url<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></blockquote><p>转载地址：<a href="https://blog.csdn.net/baidu_38493460/article/details/121016140">https://blog.csdn.net/baidu_38493460/article/details/121016140</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> HTML </tag>
            
            <tag> css </tag>
            
            <tag> VUE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>介绍</title>
      <link href="/2022/08/18/introduce/"/>
      <url>/2022/08/18/introduce/</url>
      
        <content type="html"><![CDATA[<p>生活中无论有什么闪失，统统是自己的错，与人无尤，从错处学习改过，精益求精，至不犯同一错误，从不把过失推诿到他人肩膀上去，免得失去学乖的机会。——《阿修罗》</p><h2 id="第二篇"><a href="#第二篇" class="headerlink" title="第二篇"></a>第二篇</h2><h3 id="待添加"><a href="#待添加" class="headerlink" title="待添加"></a>待添加</h3><pre class=" language-bash"><code class="language-bash">待添加</code></pre><p>百度: <a href="https://www.baidu.com/">一下</a></p><h3 id="待添加-1"><a href="#待添加-1" class="headerlink" title="待添加"></a>待添加</h3><pre class=" language-bash"><code class="language-bash">待添加</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="待添加-2"><a href="#待添加-2" class="headerlink" title="待添加"></a>待添加</h3><pre class=" language-bash"><code class="language-bash">待添加</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="待添加-3"><a href="#待添加-3" class="headerlink" title="待添加"></a>待添加</h3><pre class=" language-bash"><code class="language-bash">待添加</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 介绍 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 介绍 </tag>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客搭建</title>
      <link href="/2022/08/16/hello-world/"/>
      <url>/2022/08/16/hello-world/</url>
      
        <content type="html"><![CDATA[<p>生活还没有教会我们一笑而过的本领，我们还是会一次次地摔倒，只是不会再那么害怕疼痛了。没有了软肋，也就不需要铠甲，爬起来拍拍土，继续向前走，伤口总会愈合的。虽然生活里没有完全的公平，但上天愿给给予努力生活的人以公平对待。即便沿途处处可见迷雾、断崖，你还是要往远方去。即使江面水雾弥漫，渡口渺茫，你还是要到对岸去。即使一生都在摸索爱的真相，你还是要穿越生命保持敬畏。力量有很多种，心平气和的那种最坚定。</p><h2 id="第一篇"><a href="#第一篇" class="headerlink" title="第一篇"></a>第一篇</h2><h3 id="我的博客地址"><a href="#我的博客地址" class="headerlink" title="我的博客地址"></a>我的博客地址</h3><pre class=" language-bash"><code class="language-bash">我的博客地址1: <span class="token punctuation">(</span>https://ningsmallwhite.github.io/<span class="token punctuation">)</span></code></pre><p>宁: <a href="https://ningsmallwhite.github.io/">小白</a></p><h3 id="教程完整地址"><a href="#教程完整地址" class="headerlink" title="教程完整地址"></a>教程完整地址</h3><pre class=" language-bash"><code class="language-bash">hexo搭建博客<span class="token punctuation">(</span>https://www.bilibili.com/read/cv12633102<span class="token punctuation">)</span></code></pre><p>教程地址: <a href="https://www.bilibili.com/read/cv12633102">教程</a></p><h3 id="hexo官网"><a href="#hexo官网" class="headerlink" title="hexo官网"></a>hexo官网</h3><pre class=" language-bash"><code class="language-bash">快速、简洁且高效的博客框架</code></pre><p>官网: <a href="https://hexo.io/zh-cn/index.html">hexo</a></p><h3 id="GitHub官网"><a href="#GitHub官网" class="headerlink" title="GitHub官网"></a>GitHub官网</h3><pre class=" language-bash"><code class="language-bash">github是一个基于git的代码托管平台，付费用户可以建私人仓库，我们一般的免费用户只能使用公共仓库，也就是代码要公开。</code></pre><p>官网: <a href="https://github.com/">GitHub</a></p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搭建过程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
